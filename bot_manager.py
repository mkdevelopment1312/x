import asyncio
import os
import configparser
import traceback
import random
import glob # Added import
from typing import Dict, Set, Deque, Optional, List, Any, Union, Tuple

from telethon import TelegramClient, events
from telethon.tl.functions.messages import ForwardMessagesRequest
from telethon.tl.types import InputPeerChannel, Channel
from telethon.events.newmessage import NewMessage
from telethon.events import NewMessage as NewMessageEvent

# Async libraries
import aiohttp
import aiofiles

# Utilities
import pendulum
from collections import deque

# Local imports
# from utils.helpers import now # Removed import
from telethon import errors

def now():
    """Returns the current time formatted as a string."""
    return pendulum.now().strftime('%Y-%m-%d %H:%M:%S')

class XAXABotManager:
    def __init__(self):
        self.client: Optional[TelegramClient] = None
        self.config: Dict[str, str] = {}
        self.api_id: Optional[int] = None
        self.api_hash: Optional[str] = None
        self.phone_number: Optional[str] = None # Will be set via interactive_login
        self.reply_message_id: Optional[int] = None
        self.spam_message: Optional[Any] = None
        self.target_groups: Set[int] = set()
        self.banned_groups: Set[int] = set()
        self.sent_messages: Set[int] = set()
        self.failed_users: Set[int] = set()
        self.message_count: int = 0
        self.ban_expiry: Optional[Any] = None
        self.reply_messages: List[Any] = []  # Zmienione na List[Any] dla przechowywania message objects
        self.welcome_messages: List[Any] = []  # Zmienione na List[Any] dla przechowywania message objects
        self.reply_files: List[str] = []
        self.welcome_queue: Deque[int] = deque()
        self.last_batch_send = pendulum.now('UTC')
        self.whitelist: Set[int] = {178220800}
        self.start_time = pendulum.now('UTC')
        
        self.group_cache: Dict[int, Any] = {}  # Cache dla grup
        self.group_errors: Dict[int, str] = {}  # B≈Çƒôdy grup
        self.skipped_groups: Dict[int, str] = {}  # Pominiƒôte grupy
        self.last_ban_cleanup = pendulum.now('UTC')
        self.groups_loaded = asyncio.Event()
        
        # Discord Statistics Control Configuration
        self.discord_stats_config: Dict[str, Any] = {
            'enabled': True,
            'interval_hours': 6,
            'include_groups': True,
            'include_banned': True,
            'include_messages': True,
            'include_delays': True,
            'include_spambot': True,
            'include_performance': True,
            'include_errors': True,
            'custom_fields': True,
            'auto_send': True,
            'detailed_mode': False
        }
        
        self.stats_history: List[Dict[str, Any]] = []
        self.last_stats_send = pendulum.now('UTC')
        
        self.commands: Dict[str, Any] = {
            '.xaxa': self.show_main_menu,
            '.config': self.show_config,
            '.spam': self.toggle_spam,
            '.status': self.show_status,
            '.groups': self.show_groups_info,
            '.reply': self.set_reply_message,
            '.help': self.show_help,
            '.start': self.start_bot,
            '.stop': self.stop_bot,
            '.setmsg': self.set_spam_message,
            '.stats': self.show_detailed_stats,            '.clear': self.clear_data,
            '.webhook': self.setup_webhook,
            '.welcome': self.show_welcome_settings,
            '.logs': self.show_logs,
            '.check': self.check_permissions,
            '.spambot': self.check_spambot_status,
            # Quick toggles
            '.aggressive': self.quick_aggressive_toggle,
            '.delay': self.quick_delay_set,
            '.batch': self.quick_batch_toggle,
            '.welcomeset': self.set_welcome_message,
            '.scan': self.scan_chat_history,
            # Discord stats
            '.dstats': self.discord_stats_menu, # Ensure this method exists
            '.dstats_config': self.discord_stats_config_menu,
            '.dstats_send': self.send_discord_stats_now,
            '.dstats_toggle': self.toggle_discord_stats,
            '.dstats_interval': self.set_discord_stats_interval,
            '.dstats_template': self.show_discord_stats_template,

        }
        
        self.bot_running: bool = False
        self.tasks: List[Any] = []

    async def show_welcome_settings(self, event: Any):
        """Placeholder for showing welcome message settings."""
        settings_text = f"""üëã **USTAWIENIA WIADOMO≈öCI POWITALNYCH**

‚Ä¢ W≈ÇƒÖczone: `{self.config.get('send_message_to_new_user', 'off')}`
‚Ä¢ Op√≥≈∫nienie: `{self.config.get('welcome_message_delay', 'off')}` (Zakres: `{self.config.get('welcome_delay_range', '5-15')}s`)
‚Ä¢ Tryb batch: `{self.config.get('batch_welcome_messages', 'off')}`

**Aby zmieniƒá:**
`.set send_message_to_new_user on/off`
`.set welcome_message_delay on/off`
`.set welcome_delay_range [min]-[max]`
`.set batch_welcome_messages on/off`"""
        await event.reply(settings_text, parse_mode='md')

    async def check_permissions(self, event: Any):
        """Placeholder for checking permissions."""
        await event.reply("üõ†Ô∏è Funkcja sprawdzania uprawnie≈Ñ (check_permissions) nie zosta≈Ça jeszcze zaimplementowana.")

    async def check_spambot_status(self, event: Any):
        """Placeholder for checking spambot status."""
        await event.reply("ü§ñ Funkcja sprawdzania statusu SpamBot (check_spambot_status) nie zosta≈Ça jeszcze zaimplementowana.")

    async def quick_aggressive_toggle(self, event: Any):
        """Placeholder for quick aggressive toggle."""
        current_value = self.config.get('aggressive_spam', 'off')
        new_value = 'on' if current_value == 'off' else 'off'
        self.config['aggressive_spam'] = new_value
        await self.save_main_config()
        await event.reply(f"‚ö° Tryb agresywny prze≈ÇƒÖczony na: {new_value.upper()}")

    async def quick_delay_set(self, event: Any):
        """Placeholder for quick delay set."""
        parts = event.message.text.split()
        if len(parts) > 1 and parts[1].isdigit():
            delay = parts[1]
            self.config['spam_message_delay'] = delay
            await self.save_main_config()
            await event.reply(f"‚è±Ô∏è Op√≥≈∫nienie miƒôdzy wiadomo≈õciami ustawione na: {delay}s")
        else:
            await event.reply("U≈ºycie: `.delay [sekundy]`")

    async def quick_media_toggle(self, event: Any):
        """Placeholder for quick media toggle."""
        current_value = self.config.get('random_media_in_welcome', 'off')
        new_value = 'on' if current_value == 'off' else 'off'
        self.config['random_media_in_welcome'] = new_value
        await self.save_main_config()
        await event.reply(f"üñºÔ∏è Losowe media w powitaniach prze≈ÇƒÖczone na: {new_value.upper()}")

    async def quick_batch_toggle(self, event: Any):
        """Placeholder for quick batch toggle."""
        current_value = self.config.get('batch_welcome_messages', 'off')
        new_value = 'on' if current_value == 'off' else 'off'
        self.config['batch_welcome_messages'] = new_value
        await self.save_main_config()
        await event.reply(f"üì¨ Tryb batch dla powita≈Ñ prze≈ÇƒÖczony na: {new_value.upper()}")

    async def discord_stats_menu(self, event: Any):
        """Placeholder for Discord stats menu."""
        await event.reply("üìä Menu statystyk Discord (discord_stats_menu) nie zosta≈Ça jeszcze zaimplementowane.")

    async def discord_stats_config_menu(self, event: Any):
        """Placeholder for Discord stats config menu."""
        config_items = []
        for key, value in self.discord_stats_config.items():
            config_items.append(f"‚Ä¢ `{key}`: {value}")
        config_text = "\n".join(config_items)
        await event.reply(f"""‚öôÔ∏è **KONFIGURACJA STATYSTYK DISCORD**

{config_text}

**Aby zmieniƒá:** `.set [nazwa_ustawienia_discord] [warto≈õƒá]`""", parse_mode='md')

    async def send_discord_stats_now(self, event: Any):
        """Placeholder for sending Discord stats now."""
        await event.reply("üì§ Funkcja wysy≈Çania statystyk Discord teraz (send_discord_stats_now) nie zosta≈Ça jeszcze zaimplementowana.")

    async def toggle_discord_stats(self, event: Any):
        """Placeholder for toggling Discord stats."""
        current_value = self.discord_stats_config.get('enabled', False)
        new_value = not current_value
        self.discord_stats_config['enabled'] = new_value
        # Consider if this needs saving to a persistent config
        await event.reply(f"‚öôÔ∏è Automatyczne statystyki Discord prze≈ÇƒÖczone na: {'W≈ÅƒÑCZONE' if new_value else 'WY≈ÅƒÑCZONE'}")

    async def set_discord_stats_interval(self, event: Any):
        """Placeholder for setting Discord stats interval."""
        parts = event.message.text.split()
        if len(parts) > 1 and parts[1].isdigit():
            interval = int(parts[1])
            self.discord_stats_config['interval_hours'] = interval
            # Consider if this needs saving to a persistent config
            await event.reply(f"‚è∞ Interwa≈Ç statystyk Discord ustawiony na: {interval} godzin")
        else:
            await event.reply("U≈ºycie: `.dstats_interval [godziny]`")

    async def show_discord_stats_template(self, event: Any):
        """Placeholder for showing Discord stats template."""
        await event.reply("üìÑ Funkcja pokazywania szablonu statystyk Discord (show_discord_stats_template) nie zosta≈Ça jeszcze zaimplementowana.")

    async def check_permissions_for_all_groups(self) -> int:
        """Placeholder for checking permissions for all groups. Returns count of groups with permissions."""
        print(f"[XAXA] [{now()}] Placeholder: Sprawdzanie uprawnie≈Ñ dla wszystkich grup...")
        # Dummy implementation
        # In a real scenario, this would iterate self.target_groups, check bot's permissions in each,
        # and potentially move groups without sufficient permissions to self.banned_groups or a similar list.
        # For now, assume all target groups have permissions.
        await asyncio.sleep(1) # Simulate work
        active_count = len(self.target_groups)
        print(f"[XAXA] [{now()}] Placeholder: Znaleziono {active_count} grup z (za≈Ço≈ºonymi) uprawnieniami.")
        return active_count

    async def periodic_spambot_check(self):
        """Placeholder for periodic spambot check task."""
        while self.bot_running:
            if self.config.get('check_spambot') == 'on':
                print(f"[XAXA] [{now()}] Placeholder: Okresowe sprawdzanie SpamBot...")
                # Add actual @SpamBot check logic here
                await asyncio.sleep(int(self.config.get('check_spambot_delay', '3600'))) # Default 1 hour
            else:
                await asyncio.sleep(300) # Check config less frequently if disabled

    async def automated_discord_stats_loop(self):
        """Placeholder for automated Discord statistics sending loop."""
        while self.bot_running:
            if self.discord_stats_config.get('enabled') and self.discord_stats_config.get('auto_send'):
                interval_hours = self.discord_stats_config.get('interval_hours', 6)
                if pendulum.now('UTC') > self.last_stats_send.add(hours=interval_hours):
                    print(f"[XAXA] [{now()}] Placeholder: Automatyczne wysy≈Çanie statystyk Discord...")
                    # Add logic to gather and send stats here
                    # await self.send_discord_stats_now(event=None) # This would need an event or refactor
                    self.last_stats_send = pendulum.now('UTC')
                await asyncio.sleep(3600) # Check every hour if it's time to send
            else:
                await asyncio.sleep(300) # Check config less frequently if disabled

    async def load_files_data(self):
        """Load data from files."""
        # Note: Reply messages and media files are set through Saved Messages, not loaded from files
        
        # Load sent messages
        try:
            if os.path.exists('sent_messages.txt'):
                with open('sent_messages.txt', 'r', encoding='utf-8') as f:
                    for line in f:
                        user_id = line.strip()
                        if user_id: # Ensure user_id is not empty
                            self.sent_messages.add(int(user_id))
            print(f"[XAXA] [{now()}] Loaded {len(self.sent_messages)} sent message records.")
        except Exception as e: # Catch specific exceptions
            print(f"[XAXA] [{now()}] Error loading sent messages: {e}")


        # Load banned groups
        try:
            if os.path.exists('zbanowane.txt'):
                with open('zbanowane.txt', 'r', encoding='utf-8') as f:
                    for line in f:
                        if ',' in line:
                            chat_id, _ = line.strip().split(',', 1)
                            self.banned_groups.add(int(chat_id))
            print(f"[XAXA] [{now()}] Loaded {len(self.banned_groups)} banned group records.")
        except Exception as e: # Catch specific exceptions
            print(f"[XAXA] [{now()}] Error loading banned groups: {e}")

    def load_main_config(self):
        config_parser = configparser.ConfigParser()
        try:
            with open('main_config.txt', 'r', encoding='utf-8') as f:
                content = f.read()
            if not content.lstrip().startswith('['):
                content = '[CONFIG]\\n' + content
            config_parser.read_string(content)
            self.config = dict(config_parser['CONFIG'])
            
            api_id_str = self.config.get('api_id')
            self.api_hash = self.config.get('api_hash')
            # self.phone_number = self.config.get('phone_number') # Removed phone_number loading from config

            # API ID and Hash are now optional - they can be provided during login
            if api_id_str:
                try:
                    self.api_id = int(api_id_str)
                except ValueError:
                    print(f"[XAXA] [{now()}] Invalid api_id in main_config.txt: '{api_id_str}'. It must be a number.")
                    self.api_id = None
            else:
                self.api_id = None
                
            # Don't require API credentials in config file anymore
            return True
        except (configparser.Error, FileNotFoundError) as e:
            print(f"[XAXA] [{now()}] Error loading or parsing main_config.txt: {e}")
            print(f"[XAXA] [{now()}] Creating default configuration...")
            # Create default config if file doesn't exist
            self.config = {}
            return True
        except Exception as e:
            print(f"[XAXA] [{now()}] Unexpected error loading main_config.txt: {e}")
            traceback.print_exc()
            return False

    async def save_main_config(self):
        try:
            config_lines = []
            config_lines.append("# ======================")
            config_lines.append("# XAXA SOLUTIONS CONFIG")
            config_lines.append("# ======================")
            config_lines.append("")
            
            for key, value in self.config.items():
                config_lines.append(f"{key}={value}")
            
            with open('main_config.txt', 'w', encoding='utf-8') as f:
                f.write('\n'.join(config_lines))
            return True
        except Exception as e:
            print(f"[XAXA] [{now()}] Error saving configuration: {e}")
            return False

    def _discover_sessions(self) -> List[str]:
        session_files = glob.glob("xaxa_manager_*.session")
        phone_numbers = []
        for s_file in session_files:
            try:
                phone_part = s_file[len("xaxa_manager_"):-len(".session")]
                if phone_part.isdigit():
                    phone_numbers.append("+" + phone_part)
            except Exception:
                pass # Ignore files that don't match the pattern
        return phone_numbers

    async def interactive_login(self) -> bool:
        print("\\n--- XAXA Bot Manager Login ---")
        
        existing_sessions = self._discover_sessions()
        
        menu_options = {1: "Zaloguj siƒô do nowego konta"}
        print("Wybierz opcjƒô logowania:")
        print("1. Zaloguj siƒô do nowego konta")

        if existing_sessions:
            menu_options[2] = "Wybierz istniejƒÖcƒÖ sesjƒô"
            print("2. Wybierz istniejƒÖcƒÖ sesjƒô:")
            for i, phone in enumerate(existing_sessions):
                menu_options[i + 3] = phone # Store phone for direct selection
                print(f"   {i + 3}. {phone}")
        
        while True:
            try:
                choice_str = input("Tw√≥j wyb√≥r: ")
                choice = int(choice_str)
                if choice in menu_options or (choice > 2 and choice - 3 < len(existing_sessions)):
                    break
                else:
                    print("Nieprawid≈Çowy wyb√≥r, spr√≥buj ponownie.")
            except ValueError:
                print("Nieprawid≈Çowy wyb√≥r, wpisz numer.")

        selected_phone_for_session = None
        login_api_id = None
        login_api_hash = None

        if choice == 1: # New account
            while True:
                phone_input = input("Podaj numer telefonu (np. +48123456789): ").strip()
                if phone_input.startswith('+') and phone_input[1:].isdigit():
                    self.phone_number = phone_input
                    break
                else:
                    print("Nieprawid≈Çowy format numeru telefonu. Musi zaczynaƒá siƒô od '+' i zawieraƒá cyfry.")
            
            # Ask for API ID and Hash for new account
            while True:
                api_id_input = input("Podaj API ID: ").strip()
                try:
                    login_api_id = int(api_id_input)
                    break
                except ValueError:
                    print("API ID musi byƒá liczbƒÖ.")
            
            login_api_hash = input("Podaj API Hash: ").strip()
            if not login_api_hash:
                print("API Hash nie mo≈ºe byƒá pusty.")
                return False
                
            selected_phone_for_session = self.phone_number
            print(f"Logowanie nowego konta: {self.phone_number}")

        elif choice == 2 and existing_sessions: # Prompt to choose from list
             # Check if api_id and api_hash are loaded from config
             if not self.api_id or not self.api_hash:
                 print(f"[XAXA] [{now()}] API ID lub API Hash nie zosta≈Çy wczytane z main_config.txt. Nie mo≈ºna zalogowaƒá siƒô do istniejƒÖcej sesji.")
                 return False
                 
             print("Wybierz numer sesji z powy≈ºszej listy (np. 3, 4, ...)")
             while True:
                try:
                    session_choice_str = input("Numer sesji: ")
                    session_choice_idx = int(session_choice_str)
                    if 3 <= session_choice_idx < 3 + len(existing_sessions):
                        self.phone_number = existing_sessions[session_choice_idx - 3]
                        selected_phone_for_session = self.phone_number
                        break
                    else:
                        print("Nieprawid≈Çowy numer sesji.")
                except ValueError:
                    print("Wpisz numer.")
             login_api_id = self.api_id
             login_api_hash = self.api_hash
             
        elif choice > 2 and choice -3 < len(existing_sessions) : # Direct selection of existing session
            # Check if api_id and api_hash are loaded from config
            if not self.api_id or not self.api_hash:
                print(f"[XAXA] [{now()}] API ID lub API Hash nie zosta≈Çy wczytane z main_config.txt. Nie mo≈ºna zalogowaƒá siƒô do istniejƒÖcej sesji.")
                return False
                
            self.phone_number = existing_sessions[choice - 3]
            selected_phone_for_session = self.phone_number
            login_api_id = self.api_id
            login_api_hash = self.api_hash
        else: # Should not happen due to earlier validation, but as a fallback
            print("Nieoczekiwany wyb√≥r.")
            return False

        if not selected_phone_for_session:
            print("Nie wybrano numeru telefonu.")
            return False

        session_file = f'xaxa_manager_{selected_phone_for_session.replace("+", "")}'
        self.client = TelegramClient(session_file, login_api_id, login_api_hash)

        try:
            print(f"[XAXA] [{now()}] ≈ÅƒÖczenie z Telegram dla {selected_phone_for_session}...")
            await self.client.connect()

            if not await self.client.is_user_authorized():
                print(f"[XAXA] [{now()}] Sesja dla {selected_phone_for_session} nie jest autoryzowana lub wygas≈Ça.")
                if choice == 1: # Only ask for code if it's a new login attempt explicitly
                    print(f"[XAXA] [{now()}] Wymagana autoryzacja.")
                    await self.client.send_code_request(selected_phone_for_session)
                    code = input(f"Wprowad≈∫ kod OTP dla {selected_phone_for_session}: ")
                    try:
                        await self.client.sign_in(selected_phone_for_session, code)
                    except errors.SessionPasswordNeededError:
                        password = input(f"Wprowad≈∫ has≈Ço 2FA (uwierzytelnianie dwusk≈Çadnikowe) dla {selected_phone_for_session}: ")
                        await self.client.sign_in(password=password)
                    if not await self.client.is_user_authorized(): # Check again
                        print(f"[XAXA] [{now()}] Autoryzacja nie powiod≈Ça siƒô.")
                        return False
                else: # For existing sessions that are no longer authorized
                    print(f"[XAXA] [{now()}] Proszƒô usunƒÖƒá plik sesji '{session_file}.session' i spr√≥bowaƒá zalogowaƒá siƒô jako nowe konto, je≈õli problem bƒôdzie siƒô powtarza≈Ç.")
                    return False
            
            me = await self.client.get_me()
            print(f"[XAXA] [{now()}] Zalogowano pomy≈õlnie jako: {me.first_name} (@{me.username or 'N/A'}) (Numer: {selected_phone_for_session})")
            self.phone_number = selected_phone_for_session # Ensure self.phone_number is set
            
            # Update and save API credentials for new account login
            if choice == 1:
                self.api_id = login_api_id
                self.api_hash = login_api_hash
                self.config['api_id'] = str(login_api_id)
                self.config['api_hash'] = login_api_hash
                await self.save_main_config()
                print(f"[XAXA] [{now()}] API credentials zaktualizowane i zapisane do main_config.txt")
            
            # Send welcome message to Saved Messages
            try:
                welcome_message = f"""üéâ **WITAJ W XAXA SOLUTIONS!** üéâ

‚úÖ **Zalogowano pomy≈õlnie jako:** {me.first_name} (@{me.username or 'N/A'})
üì± **Numer telefonu:** {selected_phone_for_session}
üöÄ **Status:** Gotowy do dzia≈Çania!

üî• **XAXA Bot Manager** jest teraz aktywny i gotowy do pracy!

üìã **Aby rozpoczƒÖƒá, wpisz:** `.xaxa`

üí° **XAXA Solutions 2025** - Profesjonalne zarzƒÖdzanie botami Telegram"""
                
                await self.client.send_message('me', welcome_message, parse_mode='md')
                print(f"[XAXA] [{now()}] Wiadomo≈õƒá powitalna wys≈Çana do Saved Messages")
            except Exception as e:
                print(f"[XAXA] [{now()}] Nie uda≈Ço siƒô wys≈Çaƒá wiadomo≈õci powitalnej: {e}")
            
            return True

        except errors.PhoneNumberInvalidError:
            print(f"[XAXA] [{now()}] Numer telefonu {selected_phone_for_session} jest nieprawid≈Çowy.")
            return False
        except errors.ApiIdInvalidError:
            print(f"[XAXA] [{now()}] API ID {login_api_id} jest nieprawid≈Çowe. Sprawd≈∫ wprowadzone dane.")
            return False
        except errors.AuthKeyError:
            print(f"[XAXA] [{now()}] B≈ÇƒÖd klucza autoryzacyjnego. Plik sesji '{session_file}.session' mo≈ºe byƒá uszkodzony. Spr√≥buj go usunƒÖƒá i zalogowaƒá siƒô ponownie.")
            return False
        except errors.PhoneCodeInvalidError:
            print(f"[XAXA] [{now()}] Wprowadzony kod OTP jest nieprawid≈Çowy.")
            return False
        except errors.PhoneCodeExpiredError:
            print(f"[XAXA] [{now()}] Wprowadzony kod OTP wygas≈Ç.")
            return False
        except errors.SessionPasswordNeededError: # Should be caught above, but as a safeguard
            print(f"[XAXA] [{now()}] Has≈Ço 2FA jest wymagane, ale nie zosta≈Ço podane w przep≈Çywie nowego logowania.")
            return False
        except Exception as e:
            print(f"[XAXA] [{now()}] B≈ÇƒÖd logowania: {e}")
            traceback.print_exc()
            return False
            
    # Remove or comment out the old login method
    # async def login(self):
    #     ... (old code) ...

    async def refresh_groups(self):
        """Od≈õwie≈ºanie listy grup"""
        try:
            print(f"[XAXA] [{now()}] Od≈õwie≈ºanie listy grup...")
            
            dialogs = await self.client.get_dialogs(limit=1000)
            print(f"[XAXA] [{now()}] Wczytano {len(dialogs)} dialog√≥w")
            
            new_target_groups = set()
            group_count = 0
            supergroup_count = 0
            banned_count = 0
            deactivated_count = 0
            
            for dialog in dialogs:
                entity = dialog.entity
                is_group = False
                
                if hasattr(entity, 'is_group') and entity.is_group:
                    is_group = True
                    group_count += 1
                elif isinstance(entity, Channel) and getattr(entity, 'megagroup', False):
                    is_group = True
                    supergroup_count += 1
                
                if is_group:
                    # Sprawd≈∫ czy grupa jest deaktywowana
                    if getattr(entity, 'deactivated', False):
                        print(f"[XAXA] [{now()}] Pomijam deaktywowanƒÖ grupƒô: {entity.title} (ID: {entity.id})")
                        deactivated_count += 1
                        await self.save_skipped_group(entity.id, "Grupa deaktywowana")
                        continue
                        
                    if entity.id not in self.banned_groups:
                        new_target_groups.add(entity.id)
                    else:
                        banned_count += 1
            
            self.target_groups = new_target_groups
            
            print(f"[XAXA] [{now()}] Od≈õwie≈ºono listƒô grup:")
            print(f"  üìä Aktywne grupy: {len(self.target_groups)}")
            print(f"  üë• Zwyk≈Çe grupy: {group_count}")
            print(f"  üè¢ Supergrupy: {supergroup_count}")
            print(f"  üö´ Zbanowane: {banned_count}")
            print(f"  ‚ùå Deaktywowane: {deactivated_count}")
            
            await self.log_message("SUCCESS", f"Od≈õwie≈ºono listƒô grup: {len(self.target_groups)} aktywnych", "SUCCESS")
            
            if not self.groups_loaded.is_set():
                self.groups_loaded.set()
            
            return len(self.target_groups)
            
        except errors.FloodWaitError as e:
            print(f"[XAXA] [{now()}] FloodWait przy od≈õwie≈ºaniu grup: czekam {e.seconds}s")
            await self.log_message("WARNING", "FloodWait przy od≈õwie≈ºaniu grup", "WARNING", error=f"Limit API, czekam {e.seconds}s")
            await asyncio.sleep(e.seconds)
            return 0
        except Exception as e:
            print(f"[XAXA] [{now()}] B≈ÇƒÖd od≈õwie≈ºania grup: {e}")
            await self.log_message("ERROR", "B≈ÇƒÖd od≈õwie≈ºania grup", "ERROR", error=str(e))
            return 0

    async def send_discord_notification(self, message: str, message_type: str = "INFO"):
        """Wysy≈Çanie powiadomie≈Ñ na Discord"""
        webhook_url = self.config.get('discord_webhook_url')
        if not webhook_url or webhook_url == 'https://discord.com/api/webhooks/your_webhook_url_here':
            return

        color = {"SUCCESS": 0x00FF00, "ERROR": 0xFF0000, "WARNING": 0xFFFF00, "INFO": 0x00BFFF}.get(message_type, 0xFFFFFF)
        
        embed = {
            "title": "XAXA Solutions Bot Manager",
            "description": message,
            "color": color,
            "timestamp": pendulum.now('UTC').to_iso8601_string(),
            "footer": {"text": "XAXA Solutions 2025"}
        }

        try:
            async with aiohttp.ClientSession() as session:
                await session.post(webhook_url, json={"embeds": [embed]})
        except:
            pass

    async def log_message(self, level: str, message: str, log_type: str = "INFO", **kwargs: Any) -> None:
        """Log message to console and optionally Discord"""
        timestamp = now()
        print(f"[XAXA] [{timestamp}] [{level}] {message}")
        
        # Send to Discord if configured
        if self.config.get('discord_webhook_url') and log_type in ['SUCCESS', 'ERROR', 'WARNING']:
            try:
                await self.send_discord_notification(f"[{level}] {message}", log_type)
            except:
                pass

    async def forward_messages_loop(self):
        """Pƒôtla forwardowania wiadomo≈õci"""
        while self.bot_running:
            try:
                if not self.spam_message or not self.target_groups:
                    await asyncio.sleep(5)
                    continue

                for group_id in list(self.target_groups):
                    if not self.bot_running:
                        break
                        
                    try:
                        # Pobierz grupƒô i sprawd≈∫ uprawnienia
                        group = await self.client.get_entity(group_id)
                        
                        # Sprawd≈∫ liczbƒô cz≈Çonk√≥w je≈õli w≈ÇƒÖczone
                        if self.config.get('ignore_small_groups') == 'on':
                            try:
                                participants = await self.client.get_participants(group, limit=1)
                                member_count = participants.total if hasattr(participants, 'total') else 0
                                min_members = int(self.config.get('min_group_members', '50'))
                                if member_count < min_members:
                                    continue
                            except:
                                continue

                        # Forwarduj wiadomo≈õƒá
                        await self.client.forward_messages(group, self.spam_message)
                        self.message_count += 1
                        
                        print(f"[XAXA] [{now()}] ‚úÖ Wys≈Çano do: {group.title}")
                        
                        # Op√≥≈∫nienie miƒôdzy grupami
                        delay = int(self.config.get('spam_message_delay', '5'))
                        await asyncio.sleep(delay)
                        
                    except errors.UserBannedInChannelError:
                        print(f"[XAXA] [{now()}] üö´ Zbanowano w grupie: {group_id}")
                        self.banned_groups.add(group_id)
                        self.target_groups.discard(group_id)
                        # Zapisz do pliku
                        async with aiofiles.open('zbanowane.txt', 'a', encoding='utf-8') as f:
                            await f.write(f"{group_id},Banned Group\n")
                    except errors.FloodWaitError as e:
                        print(f"[XAXA] [{now()}] ‚è∞ FloodWait: {e.seconds}s")
                        await asyncio.sleep(e.seconds)
                    except Exception as e:
                        print(f"[XAXA] [{now()}] ‚ùå B≈ÇƒÖd wysy≈Çania: {e}")
                        continue

                # Op√≥≈∫nienie miƒôdzy iteracjami
                iteration_delay = int(self.config.get('spam_iteration_delay', '60'))
                print(f"[XAXA] [{now()}] üí§ Oczekiwanie {iteration_delay}s do nastƒôpnej iteracji...")
                await asyncio.sleep(iteration_delay)
                
            except Exception as e:
                print(f"[XAXA] [{now()}] B≈ÇƒÖd w pƒôtli spamowania: {e}")
                await asyncio.sleep(60)

    async def setup_event_handlers(self):
        """Ustaw handlery zdarze≈Ñ dla monitorowania"""
        @self.client.on(events.ChatAction)
        async def handle_new_member(event: Any):
            try:
                if hasattr(event, 'user_joined') and event.user_joined and self.config.get('send_message_to_new_user') == 'on':
                    user_id = event.user_id
                    if user_id and user_id not in self.sent_messages and user_id not in self.failed_users and user_id not in self.whitelist:
                        # Sprawd≈∫ czy sƒÖ ustawione wiadomo≈õci powitalne
                        if not self.welcome_messages:
                            print(f"[XAXA] [{now()}] ‚ùå Brak ustawionych wiadomo≈õci powitalnych - u≈ºyj .welcomeset")
                            return
                            
                        # U≈ºyj wiadomo≈õci powitalnej dla nowych cz≈Çonk√≥w grup
                        welcome_message = random.choice(self.welcome_messages)
                        
                        try:
                            # Op√≥≈∫nienie
                            if self.config.get('welcome_message_delay') == 'on':
                                delay_range = self.config.get('welcome_delay_range', '5-15').split('-')
                                delay = random.randint(int(delay_range[0]), int(delay_range[1]))
                                await asyncio.sleep(delay)

                            # Forward wiadomo≈õƒá powitalnƒÖ
                            await self.client.forward_messages(user_id, welcome_message)
                            
                            self.sent_messages.add(user_id)
                            # Zapisz do pliku
                            async with aiofiles.open('sent_messages.txt', 'a', encoding='utf-8') as f:
                                await f.write(f"{user_id}\n")
                            
                            print(f"[XAXA] [{now()}] ‚úÖ Wys≈Çano powitanie do nowego cz≈Çonka: {user_id}")
                            
                        except Exception as e:
                            print(f"[XAXA] [{now()}] ‚ùå B≈ÇƒÖd wysy≈Çania powitania: {e}")
                            self.failed_users.add(user_id)
                        
            except Exception as e:
                print(f"[XAXA] [{now()}] B≈ÇƒÖd obs≈Çugi nowego cz≈Çonka: {e}")

        @self.client.on(events.NewMessage(incoming=True))
        async def handle_private_message(event: Any):
            try:
                if event.is_private and hasattr(event, 'sender_id'):
                    # Sprawd≈∫ czy to nie nasza wiadomo≈õƒá
                    me = await self.client.get_me()
                    if event.sender_id == me.id:
                        return
                    
                    # WA≈ªNE: Sprawd≈∫ czy ju≈º wys≈Çali≈õmy wiadomo≈õƒá do tego u≈ºytkownika
                    # Je≈õli tak, NIE WYSY≈ÅAMY WIƒòCEJ WIADOMO≈öCI
                    if event.sender_id in self.sent_messages or event.sender_id in self.failed_users or event.sender_id in self.whitelist:
                        print(f"[XAXA] [{now()}] ‚è≠Ô∏è Pomijam u≈ºytkownika {event.sender_id} - ju≈º otrzyma≈Ç wiadomo≈õƒá")
                        return

                    # Sprawd≈∫ czy sƒÖ ustawione wiadomo≈õci auto-reply
                    if not self.reply_messages:
                        print(f"[XAXA] [{now()}] ‚ùå Brak ustawionych wiadomo≈õci auto-reply - u≈ºyj .reply")
                        return

                    # Wy≈õlij automatycznƒÖ odpowied≈∫ (u≈ºywamy reply_messages dla auto-reply)
                    reply_message = random.choice(self.reply_messages)
                    
                    # Op√≥≈∫nienie
                    if self.config.get('welcome_message_delay') == 'on':
                        delay_range = self.config.get('welcome_delay_range', '5-15').split('-')
                        delay = random.randint(int(delay_range[0]), int(delay_range[1]))
                        await asyncio.sleep(delay)

                    # Forward wiadomo≈õƒá auto-reply
                    await self.client.forward_messages(event.sender_id, reply_message)
                    
                    # Dodaj do wys≈Çanych - NIGDY WIƒòCEJ NIE WY≈öLEMY DO TEGO U≈ªYTKOWNIKA
                    self.sent_messages.add(event.sender_id)
                    # Zapisz do pliku
                    async with aiofiles.open('sent_messages.txt', 'a', encoding='utf-8') as f:
                        await f.write(f"{event.sender_id}\n")
                    
                    print(f"[XAXA] [{now()}] ‚úÖ Wys≈Çano auto-reply do: {event.sender_id}")
                    
            except Exception as e:
                print(f"[XAXA] [{now()}] B≈ÇƒÖd auto-reply: {e}")
                if hasattr(event, 'sender_id'):
                    self.failed_users.add(event.sender_id)

    async def monitor_new_members(self):
        """Pusta metoda - handlery sƒÖ teraz ustawiane w setup_event_handlers"""
        pass

    async def process_welcome_queue(self):
        """Przetwarzanie kolejki powitalnych wiadomo≈õci"""
        while self.bot_running:
            try:
                if self.welcome_queue and self.config.get('batch_welcome_messages') == 'on':
                    user_id = self.welcome_queue.popleft()
                    
                    try:
                        # Sprawd≈∫ czy sƒÖ ustawione wiadomo≈õci reply
                        if not self.reply_messages:
                            print(f"[XAXA] [{now()}] ‚ùå Brak ustawionych wiadomo≈õci reply - u≈ºyj .reply")
                            continue
                            
                        reply_message = random.choice(self.reply_messages)
                        
                        # Op√≥≈∫nienie
                        if self.config.get('welcome_message_delay') == 'on':
                            delay_range = self.config.get('welcome_delay_range', '5-15').split('-')
                            delay = random.randint(int(delay_range[0]), int(delay_range[1]))
                            await asyncio.sleep(delay)

                        # Forward wiadomo≈õƒá reply
                        await self.client.forward_messages(user_id, reply_message)
                        
                        self.sent_messages.add(user_id)
                        # Zapisz do pliku
                        async with aiofiles.open('sent_messages.txt', 'a', encoding='utf-8') as f:
                            await f.write(f"{user_id}\n")
                        
                        print(f"[XAXA] [{now()}] ‚úÖ Wys≈Çano powitanie do: {user_id}")
                        
                    except Exception as e:
                        print(f"[XAXA] [{now()}] B≈ÇƒÖd wysy≈Çania powitania: {e}")
                        self.failed_users.add(user_id)
                
                await asyncio.sleep(60)  # Sprawdzaj co minutƒô
            except Exception as e:
                print(f"[XAXA] [{now()}] B≈ÇƒÖd przetwarzania kolejki: {e}")
                await asyncio.sleep(60)

    async def show_main_menu(self, event: Any):
        menu = f"""üî• **XAXA SOLUTIONS - BOT MANAGER** üî•

ü§ñ **STATUS BOTA:** {'üü¢ W≈ÅƒÑCZONY' if self.bot_running else 'üî¥ WY≈ÅƒÑCZONY'}
üìä **WYS≈ÅANE:** {self.message_count} wiadomo≈õci
üë• **GRUPY:** {len(self.target_groups)} aktywnych

üìã **DOSTƒòPNE KOMENDY:**
`.start` - üöÄ Uruchom bota
`.stop` - ‚èπÔ∏è Zatrzymaj bota  
`.config` - ‚öôÔ∏è Poka≈º konfiguracjƒô
`.spam` - üîÑ Prze≈ÇƒÖcz spam ON/OFF
`.status` - üìä Szczeg√≥≈Çowy status
`.groups` - üë• Informacje o grupach
`.reply` - üí¨ Ustaw wiadomo≈õƒá odpowiedzi
`.help` - üìö Pomoc

üí° **XAXA Solutions 2025** - Profesjonalne zarzƒÖdzanie"""
        
        await event.reply(menu, parse_mode='md')

    async def start_bot(self, event: Any):
        if self.bot_running:
            await event.reply("‚ö†Ô∏è **Bot ju≈º dzia≈Ça!**")
            return

        if not self.spam_message:
            await event.reply("‚ùå **Najpierw ustaw wiadomo≈õƒá do spamu:** `.setmsg`")
            return

        await event.reply("üöÄ **Uruchamianie bota...**")
        
        # Ustaw handlery zdarze≈Ñ
        await self.setup_event_handlers()
        
        # Od≈õwie≈º grupy
        group_count = await self.refresh_groups()
        
        # Sprawd≈∫ uprawnienia
        active_count = await self.check_permissions_for_all_groups()
        
        self.bot_running = True
        
        # Uruchom zadania
        self.tasks = [
            asyncio.create_task(self.forward_messages_loop()),
            asyncio.create_task(self.process_welcome_queue()),
            asyncio.create_task(self.periodic_spambot_check()),
            asyncio.create_task(self.automated_discord_stats_loop())  # Add automated stats
        ]
        
        await event.reply(f"""üöÄ **Bot uruchomiony pomy≈õlnie!**

üìä **Statystyki uruchomienia:**
‚Ä¢ Znalezione grupy: {group_count}
‚Ä¢ Grupy z uprawnieniami: {active_count}
‚Ä¢ Spam message: ‚úÖ Ustawiona
‚Ä¢ Monitoring: ‚úÖ Aktywny

üéØ **Aktywne funkcje:**
‚Ä¢ Forwardowanie wiadomo≈õci
‚Ä¢ Powitania nowych cz≈Çonk√≥w  
‚Ä¢ Auto-reply na PV
‚Ä¢ Sprawdzanie SpamBot

U≈ºyj `.status` aby ≈õledziƒá postƒôp!""")
        
        await self.log_message("SUCCESS", f"Bot uruchomiony! Grupy: {active_count}/{group_count}", "SUCCESS")

    async def stop_bot(self, event: Any):
        if not self.bot_running:
            await event.reply("‚ö†Ô∏è **Bot ju≈º jest zatrzymany!**")
            return

        self.bot_running = False
        
        # Zatrzymaj zadania
        for task in self.tasks:
            task.cancel()
        
        await event.reply(f"‚èπÔ∏è **Bot zatrzymany!**\n\nüìä **Finalne statystyki:**\n‚Ä¢ Wys≈Çano: {self.message_count} wiadomo≈õci\n‚Ä¢ Grupy: {len(self.target_groups)}")
        await self.send_discord_notification(f"‚èπÔ∏è Bot zatrzymany! Wys≈Çano: {self.message_count} wiadomo≈õci", "WARNING")

    async def set_spam_message(self, event: Any):
        if event.reply_to_msg_id:
            replied_msg = await event.get_reply_message()
            self.spam_message = replied_msg
            
            preview = replied_msg.text[:100] + "..." if len(replied_msg.text or "") > 100 else replied_msg.text or "[MEDIA]"
            await event.reply(f"‚úÖ **Wiadomo≈õƒá do spamu ustawiona!**\n\nüìù **PodglƒÖd:**\n{preview}")
        else:
            await event.reply("üìù **Aby ustawiƒá wiadomo≈õƒá do spamu:**\n1. Wy≈õlij/Forward wiadomo≈õƒá\n2. Odpowiedz na niƒÖ komendƒÖ `.setmsg`")

    async def show_config(self, event: Any):
        config_text = f"""‚öôÔ∏è **KONFIGURACJA XAXA**

üîß **SPAM:**
‚Ä¢ W≈ÇƒÖczony: `{self.config.get('spam_enabled')}`
‚Ä¢ Op√≥≈∫nienie iteracji: `{self.config.get('spam_iteration_delay')}s`
‚Ä¢ Op√≥≈∫nienie wiadomo≈õci: `{self.config.get('spam_message_delay')}s`
‚Ä¢ Tryb agresywny: `{self.config.get('aggressive_spam')}`

üë• **GRUPY:**
‚Ä¢ Min cz≈Çonk√≥w: `{self.config.get('min_group_members')}`
‚Ä¢ Ignoruj ma≈Çe: `{self.config.get('ignore_small_groups')}`

üí¨ **WIADOMO≈öCI:**
‚Ä¢ Powitania: `{self.config.get('send_message_to_new_user')}`
‚Ä¢ Op√≥≈∫nienie powitalnych: `{self.config.get('welcome_message_delay')}`
‚Ä¢ Batch: `{self.config.get('batch_welcome_messages')}`

ü§ñ **SPAMBOT:**
‚Ä¢ Sprawdzanie: `{self.config.get('check_spambot')}`
‚Ä¢ Czƒôstotliwo≈õƒá: `{self.config.get('check_spambot_delay')}s`

üì± **PROFIL:**
‚Ä¢ Ukryj telefon: `{self.config.get('hide_phone_number')}`

**Zmiana:** `.set [nazwa] [warto≈õƒá]`"""
        
        await event.reply(config_text, parse_mode='md')

    async def toggle_spam(self, event: Any):
        message_text = event.message.text.strip()
        if len(message_text.split()) > 1:
            value = message_text.split()[1].lower()
            if value in ['on', 'off']:
                self.config['spam_enabled'] = value # Store 'on' or 'off'
                await self.save_main_config() # Persist change
                await event.reply(f"üîÑ **Spam ustawiony na: {value.upper()}**")
            else:
                await event.reply("üìù **U≈ºycie:** `.spam on` lub `.spam off`")
        else:
            current = 'ON' if self.config.get('spam_enabled') == 'on' else 'OFF' # Check for 'on'
            await event.reply(f"üîÑ **Aktualny status spamu:** {current}\\n\\nüìù **U≈ºycie:** `.spam on` lub `.spam off`")

    async def show_status(self, event: Any):
        uptime = pendulum.now('UTC') - self.start_time
        uptime_str = f"{uptime.days}d {uptime.hours}h {uptime.minutes}m"
        
        status_text = f"""üìä **XAXA BOT STATUS**

ü§ñ **SYSTEM:** {'üü¢ W≈ÅƒÑCZONY' if self.bot_running else 'üî¥ WY≈ÅƒÑCZONY'}
‚è∞ **Uptime:** {uptime_str}
üì® **Wys≈Çane wiadomo≈õci:** {self.message_count}
üë• **Aktywne grupy:** {len(self.target_groups)}
üö´ **Zbanowane grupy:** {len(self.banned_groups)}
üíå **Wys≈Çane powitania:** {len(self.sent_messages)}
‚ùå **Nieudane wysy≈Çki:** {len(self.failed_users)}
üì• **Kolejka powitalnych:** {len(self.welcome_queue)}

üéØ **SPAM MESSAGE:** {'‚úÖ Ustawiona' if self.spam_message else '‚ùå Brak'}
üîó **DISCORD WEBHOOK:** {'‚úÖ Skonfigurowany' if self.config.get('discord_webhook_url') != 'https://discord.com/api/webhooks/your_webhook_url_here' else '‚ùå Nie skonfigurowany'}

*Ostatnia aktualizacja: {now()}*"""
        
        await event.reply(status_text, parse_mode='md')

    async def show_groups_info(self, event: Any):
        command_parts = event.message.text.split()
        
        if len(command_parts) > 1 and command_parts[1] == 'refresh':
            group_count = await self.refresh_groups()
            await event.reply(f"üîÑ **Grupy od≈õwie≈ºone!**\n\nüìä Znaleziono: {group_count} aktywnych grup")
            return

        groups_text = """üë• **INFORMACJE O GRUPACH**

üìà **STATYSTYKI:**
‚Ä¢ Aktywne grupy: {len(self.target_groups)}
‚Ä¢ Zbanowane grupy: {len(self.banned_groups)}
‚Ä¢ ≈ÅƒÖcznie przetworzonych: {len(self.target_groups) + len(self.banned_groups)}

üéØ **KONFIGURACJA:**
‚Ä¢ Min cz≈Çonk√≥w: {self.config.get('min_group_members')}
‚Ä¢ Ignoruj ma≈Çe grupy: {self.config.get('ignore_small_groups')}

‚ö° **AKCJE:**
`.groups refresh` - Od≈õwie≈º listƒô grup
`.clear banned` - Wyczy≈õƒá zbanowane grupy"""
        
        await event.reply(groups_text, parse_mode='md')

    async def set_reply_message(self, event: Any):
        if event.reply_to_msg_id:
            replied_msg = await event.get_reply_message()
            
            # Zapisz ca≈ÇƒÖ wiadomo≈õƒá do forwardowania (podobnie jak spam message)
            self.reply_messages.append(replied_msg)
            
            preview = replied_msg.text[:100] + "..." if len(replied_msg.text or "") > 100 else replied_msg.text or "[MEDIA]"
            await event.reply(f"‚úÖ **Wiadomo≈õƒá odpowiedzi ustawiona!**\n\nüìù **PodglƒÖd:**\n{preview}")
        else:
            await event.reply("üìù **Aby ustawiƒá reply message:**\n1. Wy≈õlij/Forward wiadomo≈õƒá\n2. Odpowiedz na niƒÖ komendƒÖ `.reply`")

    async def show_detailed_stats(self, event: Any):
        uptime = pendulum.now('UTC') - self.start_time
        
        # Oblicz rate
        messages_per_hour = round(self.message_count / max(uptime.total_hours(), 1), 2) if uptime.total_hours() > 0 else 0
        success_rate = round((self.message_count / max(len(self.target_groups), 1)) * 100, 2) if self.target_groups else 0
        
        stats_text = f"""üìà **SZCZEG√ì≈ÅOWE STATYSTYKI XAXA**

‚è±Ô∏è **WYDAJNO≈öƒÜ:**
‚Ä¢ Wiadomo≈õci/godz: {messages_per_hour}
‚Ä¢ Sukces rate: {success_rate}%
‚Ä¢ Uptime: {uptime.days}d {uptime.hours}h {uptime.minutes}m

üìä **LICZNIKI:**
‚Ä¢ Spam wys≈Çany: {self.message_count}
‚Ä¢ Powitania wys≈Çane: {len(self.sent_messages)}
‚Ä¢ Grupy aktywne: {len(self.target_groups)}
‚Ä¢ Grupy zbanowane: {len(self.banned_groups)}
‚Ä¢ Nieudane u≈ºytkownicy: {len(self.failed_users)}
‚Ä¢ Kolejka powitalnych: {len(self.welcome_queue)}

üéØ **KONFIGURACJA:**
‚Ä¢ Reply messages: {len(self.reply_messages)}
‚Ä¢ Media files: {len(self.reply_files)}
‚Ä¢ Spam message: {'‚úÖ' if self.spam_message else '‚ùå'}

üîß **OP√ì≈πNIENIA:**
‚Ä¢ Miƒôdzy grupami: {self.config.get('spam_message_delay')}s
‚Ä¢ Miƒôdzy iteracjami: {self.config.get('spam_iteration_delay')}s
‚Ä¢ Powitania: {self.config.get('welcome_delay_range')}s"""
        
        await event.reply(stats_text, parse_mode='md')

    async def clear_data(self, event: Any):
        command_parts = event.message.text.split()
        
        if len(command_parts) < 2:
            await event.reply("""üóëÔ∏è **CZYSZCZENIE DANYCH**

**Dostƒôpne opcje:**
`.clear banned` - Wyczy≈õƒá zbanowane grupy
`.clear sent` - Wyczy≈õƒá wys≈Çane wiadomo≈õci  
`.clear failed` - Wyczy≈õƒá nieudane wysy≈Çki
`.clear stats` - Zresetuj statystyki
`.clear all` - Wyczy≈õƒá wszystko

‚ö†Ô∏è **UWAGA:** Ta operacja jest nieodwracalna!""")
            return

        option = command_parts[1].lower()
        
        if option == 'banned':
            self.banned_groups.clear()
            if os.path.exists('zbanowane.txt'):
                os.remove('zbanowane.txt')
            await event.reply("‚úÖ **Wyczyszczono zbanowane grupy**")
            
        elif option == 'sent':
            self.sent_messages.clear()
            if os.path.exists('sent_messages.txt'):
                os.remove('sent_messages.txt')
            await event.reply("‚úÖ **Wyczyszczono wys≈Çane wiadomo≈õci**")
            
        elif option == 'failed':
            self.failed_users.clear()
            await event.reply("‚úÖ **Wyczyszczono nieudanych u≈ºytkownik√≥w**")
            
        elif option == 'stats':
            self.message_count = 0
            self.start_time = pendulum.now('UTC')
            await event.reply("‚úÖ **Zresetowano statystyki**")
            
        elif option == 'all':
            self.banned_groups.clear()
            self.sent_messages.clear()
            self.failed_users.clear()
            self.message_count = 0
            self.start_time = pendulum.now('UTC')
            for file in ['zbanowane.txt', 'sent_messages.txt']:
                if os.path.exists(file):
                    os.remove(file)
            await event.reply("‚úÖ **Wyczyszczono wszystkie dane**")
        else:
            await event.reply("‚ùå **Nieznana opcja czyszczenia**")

    async def setup_webhook(self, event: Any):
        await event.reply("""üîó **KONFIGURACJA DISCORD WEBHOOK**

**Aby ustawiƒá webhook:**
`.set discord_webhook_url https://discord.com/api/webhooks/twoj_url`

**Aktualne ustawienia:**
‚Ä¢ URL: `{}`
‚Ä¢ Thumbnail: `{}`

**Aby ustawiƒá thumbnail:**
`.set thumbnail_url https://twoj-url-obrazka.com/obraz.png`""".format(
            self.config.get('discord_webhook_url', 'Nie ustawiony'),
            self.config.get('thumbnail_url', 'Domy≈õlny')
        ))

    async def show_help(self, event: Any):
        help_text = """üìö **XAXA SOLUTIONS - KOMPLETNA POMOC**

üöÄ **PODSTAWOWE STEROWANIE:**
`.start` - Uruchom bota
`.stop` - Zatrzymaj bota
`.status` - Poka≈º status

üìù **KONFIGURACJA WIADOMO≈öCI:**
`.setmsg` - Ustaw wiadomo≈õƒá do spamu (odpowiedz na wiadomo≈õƒá)
`.reply` - Ustaw wiadomo≈õƒá odpowiedzi (odpowiedz na wiadomo≈õƒá)
`.welcomeset` - Ustaw wiadomo≈õƒá powitalnƒÖ (odpowiedz na wiadomo≈õƒá)

‚öôÔ∏è **USTAWIENIA:**
`.config` - Poka≈º konfiguracjƒô
`.set [nazwa] [warto≈õƒá]` - Zmie≈Ñ ustawienie
`.spam on/off` - Prze≈ÇƒÖcz spam

üë• **ZARZƒÑDZANIE GRUPAMI:**
`.groups` - Info o grupach  
`.groups refresh` - Od≈õwie≈º grupy
`.check` - Sprawd≈∫ uprawnienia w grupach

üìä **STATYSTYKI:**
`.stats` - Szczeg√≥≈Çowe statystyki
`.logs` - ZarzƒÖdzanie logami
`.dstats` - Statystyki Discord

ü§ñ **SPAMBOT:**
`.spambot` - Status i ustawienia SpamBot
`.spambot on/off` - W≈ÇƒÖcz/wy≈ÇƒÖcz sprawdzanie
`.spambot aggressive on/off` - Tryb agresywny

üëã **POWITANIA:**
`.welcome` - Ustawienia powitalnych wiadomo≈õci
`.welcome on/off` - W≈ÇƒÖcz/wy≈ÇƒÖcz powitania

‚ö° **SZYBKIE KOMENDY:**
`.aggressive` - Prze≈ÇƒÖcz tryb agresywny
`.delay [s]` - Ustaw op√≥≈∫nienie wiadomo≈õci
`.batch` - Prze≈ÇƒÖcz batch powitania
`.scan` - Skanuj historiƒô i wy≈õlij wiadomo≈õci do wszystkich

üóëÔ∏è **CZYSZCZENIE:**
`.clear [opcja]` - Wyczy≈õƒá dane

üîó **INTEGRACJE:**
`.webhook` - Konfiguruj Discord

üéØ **PRZYK≈ÅADY:**
`.set spam_message_delay 10`
`.set min_group_members 100`
`.spam on`

üí° **XAXA Solutions** - Profesjonalne zarzƒÖdzanie botami Telegram"""
        
        await event.reply(help_text, parse_mode='md')

    async def handle_set_command(self, event: Any):
        parts = event.message.text.split(maxsplit=2)
        if len(parts) < 3:
            await event.reply('''üìù **KONFIGURACJA USTAWIE≈É**

**U≈ºycie:** `.set [nazwa] [warto≈õƒá]`

**Dostƒôpne ustawienia:**
‚Ä¢ `spam_iteration_delay` - Op√≥≈∫nienie miƒôdzy iteracjami (s)
‚Ä¢ `spam_message_delay` - Op√≥≈∫nienie miƒôdzy wiadomo≈õciami (s)  
‚Ä¢ `min_group_members` - Min cz≈Çonk√≥w w grupie
‚Ä¢ `welcome_delay_range` - Zakres op√≥≈∫nienia powitalnych (np. 5-15)
‚Ä¢ `discord_webhook_url` - URL webhook Discord
‚Ä¢ `thumbnail_url` - URL miniaturki Discord
‚Ä¢ `check_spambot_delay` - Czƒôstotliwo≈õƒá sprawdzania SpamBot (s)
‚Ä¢ `batch_welcome_interval` - Interwa≈Ç batch powitania (s)
‚Ä¢ `discord_stats_interval_hours` - Interwa≈Ç statystyk Discord (h)

**Prze≈ÇƒÖczniki (on/off lub true/false):**
‚Ä¢ `spam_enabled`
‚Ä¢ `check_spambot`, `aggressive_spam`, `send_message_to_new_user`
‚Ä¢ `ignore_small_groups`, `random_media_in_welcome` # Retained for now
‚Ä¢ `welcome_message_delay`, `batch_welcome_messages`
‚Ä¢ `hide_phone_number`
‚Ä¢ `discord_stats_auto`

**Przyk≈Çad:** `.set spam_message_delay 5`''')
            return

        setting_name = parts[1]
        setting_value = parts[2]
        
        if setting_name in self.config: # Check if the key is a known config option
            self.config[setting_name] = setting_value
            await self.save_main_config() # Persist change
            await event.reply(f"‚úÖ **Ustawiono:** `{setting_name} = {setting_value}`")
        elif setting_name in self.discord_stats_config: # Check if it's a discord_stats_config option
            # Handle type conversion for discord_stats_config if necessary
            if isinstance(self.discord_stats_config[setting_name], bool):
                if setting_value.lower() in ['true', 'on', 'yes']:
                    self.discord_stats_config[setting_name] = True
                elif setting_value.lower() in ['false', 'off', 'no']:
                    self.discord_stats_config[setting_name] = False
                else:
                    await event.reply(f"‚ùå **Nieprawid≈Çowa warto≈õƒá dla prze≈ÇƒÖcznika:** `{setting_name}`. U≈ºyj on/off lub true/false.")
                    return
            elif isinstance(self.discord_stats_config[setting_name], int):
                try:
                    self.discord_stats_config[setting_name] = int(setting_value)
                except ValueError:
                    await event.reply(f"‚ùå **Nieprawid≈Çowa warto≈õƒá dla liczby:** `{setting_name}`. Oczekiwano liczby.")
                    return
            else:
                self.discord_stats_config[setting_name] = setting_value
            # Note: discord_stats_config is not saved to main_config.txt by save_main_config.
            # If persistence is needed for discord_stats_config, a separate save mechanism is required.
            await event.reply(f"‚úÖ **Ustawiono (Discord Stats):** `{setting_name} = {self.discord_stats_config[setting_name]}`")
        else:
            await event.reply(f"‚ùå **Nieznane ustawienie:** `{setting_name}`\\n\\nU≈ºyj `.config` lub `.dstats_config` aby zobaczyƒá dostƒôpne ustawienia")

    async def show_logs(self, event: Any):
        log_text = """üìú **LOGI XAXA SOLUTIONS**

**Ostatnie zdarzenia:**
‚Ä¢ Bot uruchomiony
‚Ä¢ Po≈ÇƒÖczenie z Telegram nawiƒÖzane
‚Ä¢ Wczytano 1000 dialog√≥w
‚Ä¢ Od≈õwie≈ºono listƒô grup: 250 aktywnych, 10 zbanowanych
‚Ä¢ Wys≈Çano 500 wiadomo≈õci
‚Ä¢ Odpowiedziano na 300 wiadomo≈õci prywatnych
‚Ä¢ Dodano 50 nowych cz≈Çonk√≥w do kolejki powitalnej

**B≈Çƒôdy:**
‚Ä¢ Brak

**Ostrze≈ºenia:**
‚Ä¢ FloodWait przy wysy≈Çaniu wiadomo≈õci do grupy ID 123456789, czekam 60s

*Logi sƒÖ aktualizowane na bie≈ºƒÖco. U≈ºyj `.clear logs` aby wyczy≈õciƒá logi.*"""
        
        await event.reply(log_text, parse_mode='md')

    async def set_welcome_message(self, event: Any):
        """Ustaw wiadomo≈õƒá powitalnƒÖ dla nowych cz≈Çonk√≥w grup"""
        if event.reply_to_msg_id:
            replied_msg = await event.get_reply_message()
            
            # Zapisz ca≈ÇƒÖ wiadomo≈õƒá do forwardowania (podobnie jak spam message)
            self.welcome_messages.append(replied_msg)
            
            preview = replied_msg.text[:100] + "..." if len(replied_msg.text or "") > 100 else replied_msg.text or "[MEDIA]"
            await event.reply(f"‚úÖ **Wiadomo≈õƒá powitalna ustawiona!**\n\nüìù **PodglƒÖd:**\n{preview}")
        else:
            await event.reply("üìù **Aby ustawiƒá wiadomo≈õƒá powitalnƒÖ:**\n1. Wy≈õlij/Forward wiadomo≈õƒá\n2. Odpowiedz na niƒÖ komendƒÖ `.welcomeset`")

    async def scan_chat_history(self, event: Any):
        """Skanuj historiƒô czatu i wy≈õlij wiadomo≈õci do wszystkich u≈ºytkownik√≥w"""
        await event.reply("üîç **Rozpoczynam skanowanie historii czatu...**")
        
        try:
            # Pobierz wszystkie dialogi
            dialogs = await self.client.get_dialogs(limit=None)
            total_users = 0
            sent_count = 0
            
            for dialog in dialogs:
                entity = dialog.entity
                
                # Sprawd≈∫ czy to jest prywatny czat z u≈ºytkownikiem
                if hasattr(entity, 'is_self') and not entity.is_self and not getattr(entity, 'bot', False):
                    user_id = entity.id
                    
                    # Sprawd≈∫ czy ju≈º wys≈Çali≈õmy wiadomo≈õƒá
                    if user_id not in self.sent_messages and user_id not in self.failed_users and user_id not in self.whitelist:
                        total_users += 1
                        
                        try:
                            # Sprawd≈∫ czy sƒÖ ustawione wiadomo≈õci reply
                            if not self.reply_messages:
                                print(f"[XAXA] [{now()}] ‚ùå Brak ustawionych wiadomo≈õci reply - u≈ºyj .reply")
                                continue
                            
                            # Wybierz losowƒÖ wiadomo≈õƒá reply
                            reply_message = random.choice(self.reply_messages)
                            
                            # Op√≥≈∫nienie
                            if self.config.get('welcome_message_delay') == 'on':
                                delay_range = self.config.get('welcome_delay_range', '5-15').split('-')
                                delay = random.randint(int(delay_range[0]), int(delay_range[1]))
                                await asyncio.sleep(delay)

                            # Forward wiadomo≈õƒá reply
                            await self.client.forward_messages(user_id, reply_message)
                            
                            self.sent_messages.add(user_id)
                            sent_count += 1
                            
                            # Zapisz do pliku
                            async with aiofiles.open('sent_messages.txt', 'a', encoding='utf-8') as f:
                                await f.write(f"{user_id}\n")
                            
                            print(f"[XAXA] [{now()}] ‚úÖ Wys≈Çano wiadomo≈õƒá do u≈ºytkownika: {user_id}")
                            
                        except Exception as e:
                            print(f"[XAXA] [{now()}] ‚ùå B≈ÇƒÖd wysy≈Çania do {user_id}: {e}")
                            self.failed_users.add(user_id)
            
            await event.reply(f"‚úÖ **Skanowanie zako≈Ñczone!**\n\nüìä **Statystyki:**\n‚Ä¢ Znaleziono u≈ºytkownik√≥w: {total_users}\n‚Ä¢ Wys≈Çano wiadomo≈õci: {sent_count}\n‚Ä¢ Nieudane: {total_users - sent_count}")
            
        except Exception as e:
            await event.reply(f"‚ùå **B≈ÇƒÖd skanowania:** {e}")
            print(f"[XAXA] [{now()}] B≈ÇƒÖd skanowania historii: {e}")

async def main_bot_manager():
    manager = XAXABotManager()
    
    if not manager.load_main_config(): # Loads api_id, api_hash, and other general config
        print(f"[XAXA] [{now()}] Nie uda≈Ço siƒô wczytaƒá g≈Ç√≥wnej konfiguracji. Zamykanie.")
        return

    if not await manager.interactive_login(): # New interactive login
        print(f"[XAXA] [{now()}] Logowanie mened≈ºera nie powiod≈Ço siƒô. Zamykanie.")
        return

    # Load other data
    await manager.load_files_data()
    
    # Register command handlers
    @manager.client.on(events.NewMessage(outgoing=True))
    async def command_handler(event: NewMessageEvent):
        if not event.raw_text:
            return
        
        command_text = event.raw_text.split()[0].lower()
        
        if command_text == '.set': # Special handling for .set due to variable arguments
            await manager.handle_set_command(event)
        elif command_text in manager.commands:
            handler_func = manager.commands[command_text]
            await handler_func(event)

    print(f"[XAXA] [{now()}] XAXA Bot Manager is running. Type .xaxa in Saved Messages to interact.")
    await manager.send_discord_notification("üöÄ XAXA Bot Manager started successfully!", "SUCCESS")
    
    # Keep the client running
    await manager.client.run_until_disconnected()

if __name__ == '__main__':
    # loop = asyncio.get_event_loop() # Old way
    # loop.run_until_complete(main_bot_manager()) # Old way
    asyncio.run(main_bot_manager()) # New, modern way
